#!/hive/sbin/bash
#Send stats, receives commands

INTERVAL=10
RIG_CONF="/hive-config/rig.conf"
#NVIDIA_OC_CONF="/hive-config/nvidia-oc.conf"
#AMD_OC_CONF="/hive-config/amd-oc.conf"
WALLET_CONF="/hive-config/wallet.conf"
#LOG="/var/log/hive-agent.log"
LOG="/dev/null"
MINER="asicminer"

API_TIMEOUT=15 #timeout to wait for miner API response, can take very long time on 13+ gpus

[ -t 1 ] && . colors

#$PPID - might be parent screen pid
screen_count=`screen -ls | grep "\.agent" | grep -v $PPID | wc -l`

#there will be still 1 process for subshell
#[[ `ps aux | grep "./agent" | grep -vE "grep|screen|SCREEN|$$" | wc -l` > 1 ]] &&
[[ $screen_count > 0 ]] &&
	echo -e "${RED}Agent screen is already running${NOCOLOR}\nRun ${CYAN}agent-screen${NOCOLOR} to resume screen" &&
	exit 1

. asic-model
echo -e "Detected ASIC model: ${CYAN}$ASIC_MODEL${NOCOLOR}\n"
[[ $WD_ENABLED=1 ]] && nohup wd stop && nohup sleep 5; wd start &

########################################################################################################################

miner_stats () {
	local miner=$1
	local mindex=$2 #empty or 2

	khs=0
	stats=
	stats_raw=
	max_fan_rpm=$MAX_FAN_RPM
	case $ASIC_MODEL in
		"Antminer S9"|"Antminer T9+"*|"Antminer S9i"|"Antminer E3"|"Antminer S9 Hydro"|"Antminer S9 (vnish"*|"Antminer S9"*|"Antminer "|"Antminer T9"*|"Antminer T17"|"Antminer S17"*|"Antminer T15"|"Antminer S15"|"Antminer S9j"|"Antminer S11"|"Minecenter S9")
			stats_raw=`echo '{"command":"stats"}' | timeout -t 7 nc localhost 4029 | tr -d '\0\n'`
			if [[ $? -ne 0 || -z $stats_raw ]]; then
				echo -e "${YELLOW}Failed to read $miner stats from localhost:4029${NOCOLOR}"
			else
				stats_raw=$(sed 's/}{/\},{/' <<< "$stats_raw")
				local STATS=$(jq '.STATS' <<< "$stats_raw")

				#if [[ -z $algo || $algo == "null" ]]; then
				#	algo=`echo '{"command":"coin"}' | nc -w $API_TIMEOUT localhost 4029 | jq '.COIN."Hash Method"'`
				#fi

				local algo=$ASIC_ALGO
				local hs_units=$HASH
				local uptime=$(jq -r '.[1].Elapsed' <<< "$STATS")
				khs=$(jq -r '.[1]."GHS 5s"' <<< "$STATS") #14162.91 gh/s = 14 th/s
				if [[ $HASH == "mhs" ]]; then
					khs=$(awk '{print $1 * 1000}' <<< "$khs")
				elif [[ $HASH == "khs" ]]; then
					khs=$(awk '{print $1}' <<< "$khs")
				elif [[ $HASH == "hs" ]]; then
					khs=$(awk '{print $1 / 1000}' <<< "$khs")
				else
					khs=$(awk '{print $1 * 1000000}' <<< "$khs")
				fi
				local stats_pool=`echo '{"command":"pools"}' | timeout -t 7 nc localhost 4029 | tr -d '\0' | jq '.POOLS'`
				local active_pool=$(echo $stats_pool | jq '[. as $object | keys[] | select($object[.]."Stratum Active" == true  and $object[.]."Priority" <= 3) as $pool | select($object[$pool]."Getworks")] | .[0]')


				local hs=$( 	 (jq '.[1] | with_entries( select(.key | test("chain_rate\\d+")) ) 	| to_entries | [.[].value]') <<< "$STATS" )
				local temp=$(	 (jq '.[1] | with_entries( select(.key | test("temp2_\\d+")) ) 		| to_entries | [.[].value]') <<< "$STATS")
				local board_temp=$((jq '.[1] | with_entries( select(.key | test("temp\\d+$")) ) 	| to_entries | [.[].value]') <<< "$STATS")
				local fan=$(	 (jq '.[1] | with_entries( select(.key | test("fan\\d+")) ) 		| to_entries | [.[].value / '$max_fan_rpm' * 100 ]') <<< "$STATS")
				local fan_rpm=$( (jq '.[1] | with_entries( select(.key | test("fan\\d+")) ) 		| to_entries | [.[].value]') <<< "$STATS")
				local freq=$(	 (jq '.[1] | with_entries( select(.key | test("freq_avg\\d+")) ) 	| to_entries | [.[].value]') <<< "$STATS")
				local acn=$(	 (jq '.[1] | with_entries( select(.key | test("chain_acn\\d+")) ) 	| to_entries | [.[].value]') <<< "$STATS")
				local status=$(	 (jq '.[1] | with_entries( select(.key | test("chain_acs\\d+")) ) 	| to_entries | [.[].value]') <<< "$STATS")
				local hw_errors=$((jq '.[1] | with_entries( select(.key | test("chain_hw\\d+")) ) 	| to_entries | [.[].value]') <<< "$STATS")
				local power=$(	 (jq '.[1] | with_entries( select(.key | test("chain_power\\d+")) ) 	| to_entries | [.[].value]') <<< "$STATS")
				local asicboost=$((jq '[.[1] | with_entries( select(.key | test("chain_power$")) ) | to_entries | .[].value | test("AB") | if . == true then 1 else 0 end ]') <<< "$STATS")
				local ar=$(	 (jq -c --arg pool "$active_pool" '.[$pool|tonumber] | with_entries( select(.key | test("^Accepted","^Rejected","Get Failures")) ) | to_entries | [.[].value]') <<< "$stats_pool")

				stats=$(jq -nc \
						--arg algo "$algo" --argjson hs "$hs" --arg hs_units "$hs_units" \
						--argjson temp "$temp" --argjson board_temp "$board_temp" --argjson fan "$fan" --argjson fan_rpm "$fan_rpm" \
						--argjson freq "$freq" --argjson acn "$acn" --argjson power "$power" \
						--argjson hw_errors "$hw_errors" --argjson status "$status" \
						--arg uptime "$uptime" --argjson ar "$ar" --argjson asicboost "$asicboost" \
						'{$algo, $hs, $hs_units, $temp, $board_temp, $fan, $fan_rpm, $freq, $acn, $power, $hw_errors, $status, $uptime, $ar, $asicboost}')
			fi
		;;
		"Antminer A3"|"Antminer D3"|"Antminer L3+"*|"Antminer D3 Blissz"*|"Antminer L3++"|"Antminer Z9"*|"Antminer Z11"*|"Antminer X3"|"Antminer S7"|"Antminer DR3")
			stats_raw=`echo '{"command":"stats"}' | timeout -t 7 nc localhost 4029 | tr -d '\0'`
			if [[ $? -ne 0 || -z $stats_raw ]]; then
				echo -e "${YELLOW}Failed to read $miner stats from localhost:4029${NOCOLOR}"
			else
				stats_raw=$(sed 's/}{/\},{/' <<< "$stats_raw")
				local STATS=$(jq '.STATS' <<< "$stats_raw")

				#if [[ -z $algo || $algo == "null" ]]; then
				#	algo=`echo '{"command":"coin"}' | nc localhost 4029 | jq '.COIN."Hash Method"'`
				#fi

				local algo=$ASIC_ALGO
				local hs_units=$HASH
				local uptime=$(jq -r '.[1].Elapsed' <<< "$STATS")
				khs=$(jq -r '.[1]."GHS 5s"' <<< "$STATS") #14162.91 gh/s = 14 th/s
				if [[ $HASH == "mhs" ]]; then
					khs=$(awk '{print $1 * 1000}' <<< "$khs")
				elif [[ $HASH == "khs" ]]; then
					khs=$(awk '{print $1}' <<< "$khs")
				else
					khs=$(awk '{print $1 * 1000000}' <<< "$khs")
				fi

				#local temp=$( (jq '.[1] | with_entries( select(.key | startswith("temp2_")) | select(.value > 0) ) | .[]' | jq -sc .) <<< "$STATS" )
				#local hs=$( (jq '.[1] | with_entries( select( .key | test("chain_rate\\d+")) | select(.value != "" and .value != 0) ) | .[]' | jq -r '.' | jq -sc .) <<< "$STATS" )
				#stats=$(jq -nc --argjson hs "$hs" --argjson temp "$temp" --arg uptime "$uptime" --arg algo "$algo" '{$hs, $temp, $uptime, $algo}')

				local hs=$( 	 (jq '.[1] | with_entries( select(.key | test("chain_rate\\d+")) ) 	| to_entries | [.[].value]') <<< "$STATS" )
				local temp=$(	 (jq '.[1] | with_entries( select(.key | test("temp2_\\d+")) ) 		| to_entries | [.[].value]') <<< "$STATS")
				local board_temp=$((jq '.[1] | with_entries( select(.key | test("temp\\d+$")) ) 	| to_entries | [.[].value]') <<< "$STATS")
				local fan=$(	 (jq '.[1] | with_entries( select(.key | test("fan\\d+")) ) 		| to_entries | [.[].value / '$max_fan_rpm' * 100 ]') <<< "$STATS")
				local fan_rpm=$( (jq '.[1] | with_entries( select(.key | test("fan\\d+")) ) 		| to_entries | [.[].value]') <<< "$STATS")
				local freq=$(	 (jq '.[1] | with_entries( select(.key | test("frequency\\d+")) )       | to_entries | [.[].value]') <<< "$STATS")
				local miner_count=$((jq '.[1] | with_entries( select(.key | test("miner_count")) )      | to_entries | .[].value') <<< "$STATS")
				local acn=$(	 (jq '.[1] | with_entries( select(.key | test("chain_acn\\d+")) ) 	| to_entries | [.[].value]') <<< "$STATS")
				local status=$(	 (jq '.[1] | with_entries( select(.key | test("chain_acs\\d+")) ) 	| to_entries | [.[].value]') <<< "$STATS")
				local hw_errors=$( (jq '.[1] | with_entries( select(.key | test("chain_hw\\d+")) ) 	| to_entries | [.[].value]') <<< "$STATS")

				if [ $(echo $freq | jq -r length) -ne "$miner_count" ]; then
					local freq_new="[]"
					local freq=$((jq '.[1] | with_entries( select(.key | test("frequency")) )       | to_entries | [.[].value]') <<< "$STATS")
					local freq_num=$(echo $freq | jq -r .[0])
					for (( c=1; c<=$miner_count; c++ )); do
						freq_new=$(echo "$freq_new" | jq -r --arg freq_num "$freq_num" '[.[], $freq_num|tonumber]')
					done
				else freq_new=$freq
				fi

				stats=$(jq -nc \
						--arg algo "$algo" --argjson hs "$hs" --arg hs_units "$hs_units" \
						--argjson temp "$temp" --argjson board_temp "$board_temp" --argjson fan "$fan" --argjson fan_rpm "$fan_rpm" \
						--argjson freq "$freq_new" --argjson acn "$acn" \
						--argjson hw_errors "$hw_errors" --argjson status "$status" \
						--arg uptime "$uptime" \
						'{$algo, $hs, $hs_units, $temp, $board_temp, $fan, $fan_rpm, $freq, $acn, $hw_errors, $status, $uptime}')
			fi
		;;
		"Zig Z1+"|"Zig Z1")
			stats_raw=`echo '{"command":"stats"}' | timeout 7 nc localhost 4029 | tr -d '\0'`
			if [[ $? -ne 0 || -z $stats_raw ]]; then
				echo -e "${YELLOW}Failed to read $miner stats from localhost:4098${NOCOLOR}"
			else
				local STATS=$(jq '.STATS' <<< "$stats_raw")
				local algo=$ASIC_ALGO
				local hs_units=$HASH
				local uptime=$(jq -r '.[0].Elapsed' <<< "$STATS")
				khs=$(jq -r '.[0]."MHS 30S"' <<< "$STATS")
				if [[ $HASH == "mhs" ]]; then
					khs=$(awk '{print $1 * 1000}' <<< "$khs")
				elif [[ $HASH == "khs" ]]; then
					khs=$(awk '{print $1}' <<< "$khs")
				else
					khs=$(awk '{print $1 * 1000000}' <<< "$khs")
				fi

				local hs=$( 	 (jq '.[0] | with_entries( select(.key | test("CH\\d+") ) ) 		| to_entries | [.[].value | ."MHS 30S"]') <<< "$STATS" )
				local temp=$(	 (jq '.[0] | with_entries( select(.key | test("CH\\d+") ) ) 		| to_entries | [.[].value | ."Temperature"]') <<< "$STATS")
				local fan=$(	 (jq '.[0] | with_entries( select(.key | test("Fan In|Fan Out") ) ) 	| to_entries | [.[].value / '$max_fan_rpm' * 100 ]') <<< "$STATS")
				local fan_rpm=$( (jq '.[0] | with_entries( select(.key | test("Fan In|Fan Out") ) ) 	| to_entries | [.[].value ]') <<< "$STATS")
				local freq=$(	 (jq '.[0].Frequency as $freq | .[0] | with_entries( select(.key | test("CH\\d+") ) ) | to_entries | [.[].value | $freq ]') <<< "$STATS")
				local acn=$(	 (jq '.[0] | with_entries( select(.key | test("CH\\d+") ) ) 		| to_entries | [.[].value | .status | length ]') <<< "$STATS")
				local status=$(	 (jq '.[0] | with_entries( select(.key | test("CH\\d+") ) ) | to_entries | [.[].value | .status | [.[].accept | if . > 0 then  "o" else "x" end ] | join("") ]') <<< "$STATS")
#				local hw_errors=$( (jq '.[1] | with_entries( select(.key | test("chain_hw\\d+")) ) 	| to_entries | [.[].value]') <<< "$STATS")

				stats=$(jq -nc \
						--arg algo "$algo" --argjson hs "$hs" --arg hs_units "$hs_units" \
						--argjson temp "$temp" --argjson fan "$fan" --argjson fan_rpm "$fan_rpm" \
						--argjson freq "$freq" --argjson acn "$acn" \
						--argjson status "$status" \
						--arg uptime "$uptime" \
						'{$algo, $hs, $hs_units, $temp, $fan, $fan_rpm, $freq, $acn, $status, $uptime}')
			fi
		;;
		"b29+.g19"|"1337.PWNED"|"d9.g19"|"s11.g19"|"t3.soc"|"t3h+.soc"|"t2th+.soc"|"t2thf+.soc"|"t2thl+.soc"|"t2th.soc"|"t2tz.soc"|"t2thm.soc"|"t2thf.soc"|"t2t+.soc"|"t2ts.soc"|"t2ti.soc"|"t2t.soc")
			stats_raw=`echo '{"command":"stats"}' | timeout -t 7 nc localhost 4029 | tr -d '\0'`
			if [[ $? -ne 0 || -z $stats_raw ]]; then
				echo -e "${YELLOW}Failed to read $miner stats from localhost:4029${NOCOLOR}"
			else
				#stats_raw=$(sed 's/}{/\},{/' <<< "$stats_raw")
				local STATS=$(jq '.STATS' <<< "$stats_raw")

				#if [[ -z $algo || $algo == "null" ]]; then
				#	algo=`echo '{"command":"coin"}' | nc localhost 4029 | jq '.COIN."Hash Method"'`
				#fi

				local algo=$ASIC_ALGO
				local hs_units=$HASH
				local uptime=$(jq -r '.[0].Elapsed' <<< "$STATS")
				khs=$(cat /tmp/stats.json | jq -r '.[-1] | .[] | add')
				if [[ $HASH == "mhs" ]]; then
					khs=$(awk '{print $1 * 1000}' <<< "$khs")
				elif [[ $HASH == "khs" ]]; then
					khs=$(awk '{print $1}' <<< "$khs")
				else
					khs=$(awk '{print $1 / 1000}' <<< "$khs")
				fi

				local hs=$(cat /tmp/stats.json | jq -r '[.[-1] | .[] | .[]]')
				local temp=$(	 (jq '[.[] | with_entries( select(.key | test("^Temp$")) ) 		| to_entries | .[].value]') <<< "$STATS")
				local fan=$(	 (jq '[.[] | with_entries( select(.key | test("^Fan duty$")) ) 		| to_entries | .[].value]') <<< "$STATS")
				local freq=$(	 (jq '[.[] | with_entries( select(.key | test("^PLL")) ) 		| to_entries | .[].value]') <<< "$STATS")
				local acn=$(	 (jq '[.[] | with_entries( select(.key | test("Num chips")) ) 		| to_entries | .[].value]') <<< "$STATS")
				local status=$(	 (jq '[.[] | with_entries( select(.key | test("Num active chips")) ) 	| to_entries | .[].value]') <<< "$STATS")
				local hw_errors=$( (jq '[.[] | with_entries( select(.key | test("HW errors")) ) 	| to_entries | [.[].value] | add | select(.!=null)]') <<< "$STATS")

				stats=$(jq -nc \
						--arg algo "$algo" --argjson hs "$hs" --arg hs_units "$hs_units" \
						--argjson temp "$temp" --argjson fan "$fan" \
						--argjson freq "$freq" --argjson acn "$acn" \
						--argjson hw_errors "$hw_errors" --argjson status "$status" \
						--arg uptime "$uptime" \
						'{$algo, $hs, $hs_units, $temp, $fan, $freq, $acn, $hw_errors, $status, $uptime}')
			fi
		;;
		"T4.G19")
			stats_raw=`echo '{"command":"devs"}' | timeout -t 7 nc localhost 4029 | tr -d '\0'`
			if [[ $? -ne 0 || -z $stats_raw ]]; then
				echo -e "${YELLOW}Failed to read $miner stats from localhost:4029${NOCOLOR}"
			else
				local STATS=$(jq '.DEVS' <<< "$stats_raw")

				#if [[ -z $algo || $algo == "null" ]]; then
				#	algo=`echo '{"command":"coin"}' | nc localhost 4029 | jq '.COIN."Hash Method"'`
				#fi

				local algo=$ASIC_ALGO
				local hs_units=$HASH
				local uptime=$(jq -r '.[0]["Device Elapsed"]' <<< "$STATS")
				khs=$(jq -r '[.[]["MHS av"]] | add' <<< "$STATS")
				if [[ $HASH == "mhs" ]]; then
					khs=$(awk '{print $1 * 1000}' <<< "$khs")
				elif [[ $HASH == "khs" ]]; then
					khs=$(awk '{print $1}' <<< "$khs")
				else
					khs=$(awk '{print $1 / 1000}' <<< "$khs")
				fi

				local hs=$(	 (jq '[.[] | with_entries( select(.key | test("MHS 5s")) ) 		| to_entries | .[].value]') <<< "$STATS")
				local temp=$(	 (jq '[.[] | with_entries( select(.key | test("TempAVG")) ) 		| to_entries | .[].value]') <<< "$STATS")
				local freq=$(	 (jq '[.[] | with_entries( select(.key | test("CORE")) ) 		| to_entries | .[].value]') <<< "$STATS")
				local acn=$(	 (jq '[.[] | with_entries( select(.key | test("DUTY")) ) 		| to_entries | .[].value]') <<< "$STATS")
#				local status=$(	 (jq '[.[] | with_entries( select(.key | test("Num active chips")) ) 	| to_entries | .[].value]') <<< "$STATS")
				local hw_errors=$( (jq '[.[] | with_entries( select(.key | test("Hardware Errors")) ) 	| to_entries | .[].value]') <<< "$STATS")

				stats=$(jq -nc \
						--arg algo "$algo" --argjson hs "$hs" --arg hs_units "$hs_units" \
						--argjson temp "$temp" \
						--argjson freq "$freq" --argjson acn "$acn" \
						--argjson hw_errors "$hw_errors" \
						--arg uptime "$uptime" \
						'{$algo, $hs, $hs_units, $temp, $freq, $acn, $hw_errors, $uptime}')
			fi
		;;
		*)
			miner="unknown"
			#MINER=miner
			eval "MINER${mindex}=unknown"
		;;
	esac


	[[ -z $khs ]] && khs=0
	[[ -z $stats ]] && stats="null"

#	[[ ! -z $mindex ]] &&
#		eval "khs${mindex}"
}


########################################################################################################################

loop () {
	[[ ! -z $TIMEZONE ]] && export TZ=$TIMEZONE

	date

	[ ! -f $RIG_CONF ] && echo -e "No config $RIG_CONF" && return

	#each time read config again
	. $RIG_CONF
	. $WALLET_CONF
	

	[[ -z $MINER ]] && MINER="asicminer"
	HIVE_URL="$HIVE_HOST_URL/worker/api"

	miner_stats $MINER #khs and stats are global

	echo -en "Hashrate ${CYAN}$MINER${NOCOLOR} `[[ $khs > 0 ]] && echo -e ${YELLOW} || echo -e ${RED}`$khs${NOCOLOR} kH/s"
	echo -en "\n"
	echo $khs > /run/hive/khs


	#echo $stats
	#uptime: load averages for the past 1, 5, and 15 minutes

	[[ ! -z $META ]] && meta="$META" || meta='null'
	request=$(
	jq -n \
	--arg rig_id "$RIG_ID" \
	--arg passwd "$RIG_PASSWD" \
	--arg miner "$MINER" \
	--argjson meta "$meta" \
	--argjson miner_stats "$stats" \
	--arg total_khs "$khs" \
	--arg df "`df -h /$MOUNT | awk '{ print $4 }' | tail -n 1 | sed 's/%//'`" \
	--argjson cpuavg "[`uptime | awk -F': ' '{print $2}'`]" \
	'{
		"method": "stats", "jsonrpc": "2.0", "id": 0,
		"params": {
			$rig_id, $passwd, $miner, $meta,
			$miner_stats, $total_khs,
			$df, $cpuavg
		}
	}'
	)

	echo $request | jq '.' -c

	if [[ -z $RIG_ID ]]; then
		echo -e "${YELLOW}No RIG_ID, skipping sending stats${NOCOLOR}"
		return
	fi

	#log request
	echo "[`date`] > `echo $request | jq '.' -c`" >> $LOG
	#echo "[`date`] > $request" >> $LOG

	response=$(echo $request | jq '.' -c | curl --insecure -L --data @- \
	--connect-timeout 15 --max-time 25 --silent \
	-XPOST "${HIVE_URL}?id_rig=$RIG_ID&method=stats"  -H "Content-Type: application/json")

	exitcode=$?
	if [[ "$exitcode" -ne 0 || -z "$response" ]]; then
		echo -e "${RED}Error sending stats${NOCOLOR} $HIVE_HOST_URL" && human-curl-error $exitcode
		echo "[`date`] < ERROR SENDING STATS TO $HIVE_HOST_URL (curl code=$exitcode) \"$response\"" >> $LOG
		/hive/bin/cache-hive-ip
		return $exitcode
	fi

	#echo $response
	#echo "[`date`] < `echo $response | jq '.' -c`" >> $LOG
	echo "[`date`] < $response" >> $LOG #full response even invalid

	error=$(echo $response | jq '.error' --raw-output)
	[[ $? != 0 ]] && echo -e "${RED}Invalid response${NOCOLOR}: $HIVE_HOST_URL\n$response" && return 1
	[[ ! -z "$error" && "$error" != "null" ]] && echo -e "${RED}Error response${NOCOLOR}: $error" && return 1

	command=$(echo $response | jq '.result.command' --raw-output)

	[[ "$command" != "OK" ]] && echo "$response" | jq '.result'


	if [[ "$command" != "batch" ]]; then
		body=`echo $response | jq -c '.result'`
		do_command
	else
		count=`echo $response | jq '.result.commands|length'`
		echo "Got $count batch commands"
		for (( i=0; i < $count; i++ )); do
			body=`echo $response | jq -c ".result.commands[$i]"`
			command=
			do_command
		done
	fi
}


########################################################################################################################


do_command () {
	#body=$1
	[[ -z "$command" ]] && command=`echo $body | jq -r '.command'` #get command for batch

	#Optional command identifier
	cmd_id=$(echo "$body" | jq -r '.id')
	[[ $cmd_id == "null" ]] && cmd_id=

	case $command in
		OK)
			echo -e "${BGREEN}$command${NOCOLOR}"
		;;
		reboot)
			message ok "Rebooting" --id=$cmd_id
			echo -e "${BRED}Rebooting${NOCOLOR}"
			#nohup bash -c 'sreboot' > /tmp/nohup.log 2>&1 &
			/sbin/reboot
		;;
		upgrade)
			screen -dm -S selfupgrade bash -c '
				selfupgrade 2>&1 | tee /tmp/nohup.log
				upgrade_exitcode=${PIPESTATUS[0]}
				payload=`cat /tmp/nohup.log`
				[[ $upgrade_exitcode -eq 0 ]] &&
					echo "$payload" | message ok "Selfupgrade successful" payload --id='$cmd_id' ||
					echo "$payload" | message error "Selfupgrade failed" payload --id='$cmd_id'
			'
		;;
		"upgrade beta")
			screen -dm -S selfupgrade bash -c '
				cd /tmp && curl -L --insecure -s -O https://raw.githubusercontent.com/sMiLeYz/hiveosmirror/master/hive/bin/selfupgrade && sh selfupgrade 2>&1 | tee /tmp/nohup.log
				upgrade_exitcode=${PIPESTATUS[0]}
				payload=`cat /tmp/nohup.log`
				[[ $upgrade_exitcode -eq 0 ]] &&
					echo "$payload" | message ok "Selfupgrade successful" payload --id='$cmd_id' ||
					echo "$payload" | message error "Selfupgrade failed" payload --id='$cmd_id'
			'
		;;
		exec)
			exec=$(echo $body | jq '.exec' --raw-output)
			if [[ $ASIC_MODEL == "Zig Z1+" ]]; then
				payload=`timeout 360 bash -c "$exec" 2>&1`
			else
				payload=`timeout -t 360 bash -c "$exec" 2>&1`
			fi
			exitcode=$?
			echo "$payload"
			[[ $exitcode -eq 0 ]] &&
				echo "$payload" | message info "$exec" payload --id=$cmd_id ||
				echo "$payload" | message error "Exec failed, exitcode=$exitcode" payload --id=$cmd_id
		;;
		asic_oc)
			export asic_oc=`echo $body | jq '.asic_oc' --raw-output`
			screen -dm -S autotune bash -c '
				asic_oc $asic_oc 2>&1 | tee /tmp/nohup.log
				exitcode=${PIPESTATUS[0]}
				payload=`cat /tmp/nohup.log`
					[[ $exitcode -eq 0 ]] &&
					echo "$payload" | message ok "Overclock config successful" payload --id='$cmd_id' ||
					echo "$payload" | message error "Overclock config failed" payload --id='$cmd_id'
			'
		;;
		firmware-upgrade)
			export firmware_url=`echo $body | jq '.firmware_url' --raw-output`
			screen -dm -S upgade bash -c '
				firmware-upgrade $firmware_url 2>&1 | tee /tmp/nohup.log
				exitcode=${PIPESTATUS[0]}
				payload=`cat /tmp/nohup.log`
					[[ $exitcode -eq 0 ]] &&
					echo "$payload" | message ok "Firmware upgrade successful, rebooting..." payload --id='$cmd_id' ||
					echo "$payload" | message error "Firmware upgrade failed" payload --id='$cmd_id'
			'
		;;
		config)
			config=$(echo $body | jq '.config' --raw-output)
			justwrite=$(echo $body | jq '.justwrite' --raw-output) #don't restart miner, just write config, maybe WD settings will be updated
			if [[ ! -z $config && $config != "null" ]]; then
				#scan for password change
				echo "$config" > /tmp/rig.conf.new
				while read line; do
					[[ $line =~ ^RIG_PASSWD=\"(.*)\" ]] && NEW_PASSWD=${BASH_REMATCH[1]} && break
				done < /tmp/rig.conf.new
				rm /tmp/rig.conf.new

				# Password change ---------------------------------------------------
				if [[ $RIG_PASSWD != $NEW_PASSWD ]]; then
					echo -e "${RED}New password:${NOCOLOR} $NEW_PASSWD";

					message warning "Password change received, wait for next message..." --id=$cmd_id
					request=$(jq -n --arg rig_id "$RIG_ID" --arg passwd "$RIG_PASSWD" \
					'{ "method": "password_change_received", "params": {$rig_id, $passwd}, "jsonrpc": "2.0", "id": 0}')
					response=$(echo $request | curl --insecure -L --data @- --connect-timeout 15 --max-time 25 --silent -XPOST "${HIVE_URL}?id_rig=$RIG_ID&method=password_change_received" -H "Content-Type: application/json")

					exitcode=$?
					[ $exitcode -ne 0 ] &&
						message error "Error notifying hive about \"password_change_received\"" --id=$cmd_id &&
						return $exitcode #better exit because password will not be changed

					error=$(echo $response | jq '.error' --raw-output)
					[[ ! -z $error && $error != "null" ]] && echo -e "${RED}Server error:${NOCOLOR} `echo $response | jq '.error.message' -r`" && return 1

					echo "$response" | jq '.'
					#after this there will be new password on server, so all new request should use new one
				fi

				# Write new config and load it ---------------------------------------
				echo "$config" > $RIG_CONF && sync
				. $RIG_CONF

				# Save wallet if given -----------------------------------------------
				wallet=$(echo $body | jq '.wallet' --raw-output)
				[[ ! -z $wallet && $wallet != "null" ]] &&
					echo "$wallet" > $WALLET_CONF


				# Overclocking if given in config --------------------------------------
#				oc_if_changed


				# Final actions ---------------------------------------------------------
				if [[ "$justwrite" != 1 ]]; then
					#hostname-check
					/hive/bin/miner restart
				fi

				# Start Watchdog. It will exit if WD_ENABLED=0 ---------------------------
				[[ $WD_ENABLED=1 ]] && nohup wd stop && nohup sleep 5; wd start &

				message ok "Rig config changed" --id=$cmd_id
				#[[ $? == 0 ]] && message ok "Wallet changed, miner restarted" --id=$cmd_id || message warn "Error restarting miner" --id=$cmd_id
			else
				message error "No rig \"config\" given" --id=$cmd_id
			fi
		;;
		wallet)
			wallet=$(echo $body | jq '.wallet' --raw-output)
			if [[ ! -z $wallet && $wallet != "null" ]]; then
				echo "$wallet" > $WALLET_CONF && sync

				justwrite=
				oc_if_changed

				/hive/bin/miner restart
				[[ $? == 0 ]] && message ok "Wallet changed, miner restarted" --id=$cmd_id || message warn "Error restarting miner" --id=$cmd_id
			else
				message error "No \"wallet\" config given" --id=$cmd_id
			fi
		;;
	esac

	#Flush buffers if any files changed
	sync
}



########################################################################################################################

echo -e "\n\n[`date`] Started" >> $LOG

while true
do
	time_start=`date +%s`
	loop
	time_finish=`date +%s`

	wasted=$(( $time_finish - $time_start ))

	tosleep=$(( $INTERVAL - $wasted ))

	#echo "Sleeping $tosleep"
	echo ""

	if [[ $tosleep > 0 ]]; then
		sleep $INTERVAL
	else
		echo -e "${YELLOW}WARNING: Stats sending interval > $INTERVAL seconds, hanging driver?${NOCOLOR}"
	fi
done
